{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly){symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import getUniqueID from\"./getUniqueID\";import getTokenTypeByToken from\"./getTokenTypeByToken\";function createNode(token,tokenIndex){var type=getTokenTypeByToken(token);var content=token.content;var attributes={};if(token.attrs){attributes=token.attrs.reduce(function(prev,curr){var _curr=_slicedToArray(curr,2),name=_curr[0],value=_curr[1];return _objectSpread(_objectSpread({},prev),{},_defineProperty({},name,value));},{});}return{type:type,sourceType:token.type,sourceInfo:token.info,sourceMeta:token.meta,block:token.block,markup:token.markup,key:getUniqueID()+'_'+type,content:content,tokenIndex:tokenIndex,index:0,attributes:attributes,children:tokensToAST(token.children)};}export default function tokensToAST(tokens){var stack=[];var children=[];if(!tokens||tokens.length===0){return[];}for(var i=0;i<tokens.length;i++){var token=tokens[i];var astNode=createNode(token,i);if(!(astNode.type==='text'&&astNode.children.length===0&&astNode.content==='')){astNode.index=children.length;if(token.nesting===1){children.push(astNode);stack.push(children);children=astNode.children;}else if(token.nesting===-1){children=stack.pop();}else if(token.nesting===0){children.push(astNode);}}}return children;}","map":{"version":3,"sources":["/Users/admin/Documents/GitHub/PMCStoryBookNew/node_modules/react-native-markdown-display/src/lib/util/tokensToAST.js"],"names":["getUniqueID","getTokenTypeByToken","createNode","token","tokenIndex","type","content","attributes","attrs","reduce","prev","curr","name","value","sourceType","sourceInfo","info","sourceMeta","meta","block","markup","key","index","children","tokensToAST","tokens","stack","length","i","astNode","nesting","push","pop"],"mappings":"k6BAAA,MAAOA,CAAAA,WAAP,qBACA,MAAOC,CAAAA,mBAAP,6BAQA,QAASC,CAAAA,UAAT,CAAoBC,KAApB,CAA2BC,UAA3B,CAAuC,CACrC,GAAMC,CAAAA,IAAI,CAAGJ,mBAAmB,CAACE,KAAD,CAAhC,CACA,GAAMG,CAAAA,OAAO,CAAGH,KAAK,CAACG,OAAtB,CAEA,GAAIC,CAAAA,UAAU,CAAG,EAAjB,CAEA,GAAIJ,KAAK,CAACK,KAAV,CAAiB,CACfD,UAAU,CAAGJ,KAAK,CAACK,KAAN,CAAYC,MAAZ,CAAmB,SAACC,IAAD,CAAOC,IAAP,CAAgB,CAC9C,yBAAsBA,IAAtB,IAAOC,IAAP,UAAaC,KAAb,UACA,sCAAWH,IAAX,wBAAkBE,IAAlB,CAAyBC,KAAzB,GACD,CAHY,CAGV,EAHU,CAAb,CAID,CAED,MAAO,CACLR,IAAI,CAAJA,IADK,CAELS,UAAU,CAAEX,KAAK,CAACE,IAFb,CAGLU,UAAU,CAAEZ,KAAK,CAACa,IAHb,CAILC,UAAU,CAAEd,KAAK,CAACe,IAJb,CAKLC,KAAK,CAAEhB,KAAK,CAACgB,KALR,CAMLC,MAAM,CAAEjB,KAAK,CAACiB,MANT,CAOLC,GAAG,CAAErB,WAAW,GAAK,GAAhB,CAAsBK,IAPtB,CAQLC,OAAO,CAAPA,OARK,CASLF,UAAU,CAAVA,UATK,CAULkB,KAAK,CAAE,CAVF,CAWLf,UAAU,CAAVA,UAXK,CAYLgB,QAAQ,CAAEC,WAAW,CAACrB,KAAK,CAACoB,QAAP,CAZhB,CAAP,CAcD,CAOD,cAAe,SAASC,CAAAA,WAAT,CAAqBC,MAArB,CAA6B,CAC1C,GAAIC,CAAAA,KAAK,CAAG,EAAZ,CACA,GAAIH,CAAAA,QAAQ,CAAG,EAAf,CAEA,GAAI,CAACE,MAAD,EAAWA,MAAM,CAACE,MAAP,GAAkB,CAAjC,CAAoC,CAClC,MAAO,EAAP,CACD,CAED,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGH,MAAM,CAACE,MAA3B,CAAmCC,CAAC,EAApC,CAAwC,CACtC,GAAMzB,CAAAA,KAAK,CAAGsB,MAAM,CAACG,CAAD,CAApB,CACA,GAAMC,CAAAA,OAAO,CAAG3B,UAAU,CAACC,KAAD,CAAQyB,CAAR,CAA1B,CAEA,GACE,EACEC,OAAO,CAACxB,IAAR,GAAiB,MAAjB,EACAwB,OAAO,CAACN,QAAR,CAAiBI,MAAjB,GAA4B,CAD5B,EAEAE,OAAO,CAACvB,OAAR,GAAoB,EAHtB,CADF,CAME,CACAuB,OAAO,CAACP,KAAR,CAAgBC,QAAQ,CAACI,MAAzB,CAEA,GAAIxB,KAAK,CAAC2B,OAAN,GAAkB,CAAtB,CAAyB,CACvBP,QAAQ,CAACQ,IAAT,CAAcF,OAAd,EACAH,KAAK,CAACK,IAAN,CAAWR,QAAX,EACAA,QAAQ,CAAGM,OAAO,CAACN,QAAnB,CACD,CAJD,IAIO,IAAIpB,KAAK,CAAC2B,OAAN,GAAkB,CAAC,CAAvB,CAA0B,CAC/BP,QAAQ,CAAGG,KAAK,CAACM,GAAN,EAAX,CACD,CAFM,IAEA,IAAI7B,KAAK,CAAC2B,OAAN,GAAkB,CAAtB,CAAyB,CAC9BP,QAAQ,CAACQ,IAAT,CAAcF,OAAd,EACD,CACF,CACF,CAED,MAAON,CAAAA,QAAP,CACD","sourcesContent":["import getUniqueID from './getUniqueID';\nimport getTokenTypeByToken from './getTokenTypeByToken';\n\n/**\n *\n * @param {{type: string, tag:string, content: string, children: *, attrs: Array, meta, info, block: boolean}} token\n * @param {number} tokenIndex\n * @return {{type: string, content, tokenIndex: *, index: number, attributes: {}, children: *}}\n */\nfunction createNode(token, tokenIndex) {\n  const type = getTokenTypeByToken(token);\n  const content = token.content;\n\n  let attributes = {};\n\n  if (token.attrs) {\n    attributes = token.attrs.reduce((prev, curr) => {\n      const [name, value] = curr;\n      return {...prev, [name]: value};\n    }, {});\n  }\n\n  return {\n    type,\n    sourceType: token.type,\n    sourceInfo: token.info,\n    sourceMeta: token.meta,\n    block: token.block,\n    markup: token.markup,\n    key: getUniqueID() + '_' + type,\n    content,\n    tokenIndex,\n    index: 0,\n    attributes,\n    children: tokensToAST(token.children),\n  };\n}\n\n/**\n *\n * @param {Array<{type: string, tag:string, content: string, children: *, attrs: Array}>}tokens\n * @return {Array}\n */\nexport default function tokensToAST(tokens) {\n  let stack = [];\n  let children = [];\n\n  if (!tokens || tokens.length === 0) {\n    return [];\n  }\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const astNode = createNode(token, i);\n\n    if (\n      !(\n        astNode.type === 'text' &&\n        astNode.children.length === 0 &&\n        astNode.content === ''\n      )\n    ) {\n      astNode.index = children.length;\n\n      if (token.nesting === 1) {\n        children.push(astNode);\n        stack.push(children);\n        children = astNode.children;\n      } else if (token.nesting === -1) {\n        children = stack.pop();\n      } else if (token.nesting === 0) {\n        children.push(astNode);\n      }\n    }\n  }\n\n  return children;\n}\n"]},"metadata":{},"sourceType":"module"}